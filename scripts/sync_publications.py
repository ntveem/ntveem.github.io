#!/usr/bin/env python3
"""Sync publications from canonical ADS JSON into 02-index_publications.md.

Usage:
  python scripts/sync_publications.py --preview
  python scripts/sync_publications.py --write
"""

from __future__ import annotations

import argparse
import re
from pathlib import Path

from ads_data import AdsPaper, read_papers_json

DEFAULT_PAGE = "02-index_publications.md"
DEFAULT_ADS_JSON = "data/ads_publications.json"


def _format_author(name: str) -> str:
    if "," in name:
        last, first = [part.strip() for part in name.split(",", 1)]
    else:
        chunks = name.split()
        last = chunks[-1]
        first = " ".join(chunks[:-1])
    initials = "".join(f"{x[0]}." for x in re.split(r"[\s\-]+", first) if x)
    out = f"{last}, {initials}" if initials else last
    if last.lower() == "venumadhav" and first.lower().startswith("tejaswi"):
        return f"**{out}**"
    return out


def _is_tejaswi_name(name: str) -> bool:
    if "," in name:
        last, first = [part.strip().lower() for part in name.split(",", 1)]
    else:
        chunks = name.lower().split()
        if not chunks:
            return False
        last = chunks[-1]
        first = " ".join(chunks[:-1])
    return last == "venumadhav" and first.startswith("tejaswi")


def _tejaswi_author_label(authors: list[str]) -> str:
    for author in authors:
        if _is_tejaswi_name(author):
            return _format_author(author)
    return "**Venumadhav, T.**"


def _format_author_list(authors: list[str]) -> str:
    if not authors:
        return ""
    formatted = [_format_author(author) for author in authors]
    if len(formatted) == 1:
        return formatted[0]
    if len(formatted) == 2:
        return f"{formatted[0]} & {formatted[1]}"
    return f"{', '.join(formatted[:-1])}, & {formatted[-1]}"


def render_entries(papers: list[AdsPaper]) -> str:
    main_papers: list[AdsPaper] = []
    nth_author_papers: list[AdsPaper] = []
    for paper in papers:
        if len(paper.authors) > 12:
            nth_author_papers.append(paper)
        else:
            main_papers.append(paper)

    lines: list[str] = []
    for idx, paper in enumerate(main_papers, start=1):
        lines.append(f"{idx}. {_format_author_list(paper.authors)} ({paper.year}) <br>")
        lines.append(f"*{paper.title}* <br>")
        links = [f"[ADS]({paper.ads_url})"]
        if paper.arxiv_url:
            links.append(f"[arxiv]({paper.arxiv_url})")
        if paper.inspire_url:
            links.append(f"[INSPIRE]({paper.inspire_url})")
        lines.append(" ".join(links))
        lines.append("")

    if nth_author_papers:
        lines.append("<br>")
        lines.append("n-th author papers:")
        lines.append("")
        for idx, paper in enumerate(nth_author_papers, start=1):
            first_author = _format_author(paper.authors[0]) if paper.authors else "Unknown"
            teja_label = _tejaswi_author_label(paper.authors)
            lines.append(f"{idx}. {first_author} et al. ({paper.year}; incl. {teja_label}) <br>")
            lines.append(f"*{paper.title}* <br>")
            links = [f"[ADS]({paper.ads_url})"]
            if paper.arxiv_url:
                links.append(f"[arxiv]({paper.arxiv_url})")
            if paper.inspire_url:
                links.append(f"[INSPIRE]({paper.inspire_url})")
            lines.append(" ".join(links))
            lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def render_full_page(front_matter: str, entries: str) -> str:
    header = (
        "List of my publications on online databases:\n\n"
        "* [ADS](https://ui.adsabs.harvard.edu/search/q=author%3A%22Venumadhav%2C%20Tejaswi%22&sort=date%20desc%2C%20bibcode%20desc&p_=0)\n"
        "* [arxiv](https://arxiv.org/a/venumadhav_t_1.html)\n"
        "* [INSPIRE](https://inspirehep.net/authors/1321339)\n\n"
        "Individual links to articles and manuscripts, in reverse chronological order:\n\n"
        "<!-- AUTOGENERATED PUBLICATIONS: START -->\n"
    )
    footer = "<!-- AUTOGENERATED PUBLICATIONS: END -->\n"
    return f"{front_matter}\n{header}{entries}{footer}"


def parse_front_matter(text: str) -> tuple[str, str]:
    match = re.match(r"(?s)\A(---\n.*?\n---)\n?(.*)\Z", text)
    if not match:
        raise ValueError("Expected YAML front matter in publications page.")
    return match.group(1), match.group(2)


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--file", default=DEFAULT_PAGE)
    parser.add_argument("--ads-json", default=DEFAULT_ADS_JSON)
    parser.add_argument("--preview", action="store_true", help="Print generated list and exit.")
    parser.add_argument("--write", action="store_true", help="Write updates to publications page.")
    args = parser.parse_args()

    ads_json_path = Path(args.ads_json)
    if not ads_json_path.exists():
        raise SystemExit(f"Missing ADS data file: {ads_json_path}. Run python scripts/sync_ads_data.py first.")

    papers = read_papers_json(ads_json_path)
    entries = render_entries(papers)

    if args.preview or not args.write:
        print(entries)
        if not args.write:
            return 0

    target = Path(args.file)
    original = target.read_text(encoding="utf-8")
    front_matter, _ = parse_front_matter(original)
    updated = render_full_page(front_matter, entries)
    if updated != original:
        target.write_text(updated, encoding="utf-8")
        print(f"Updated {target}")
    else:
        print(f"No changes in {target}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
